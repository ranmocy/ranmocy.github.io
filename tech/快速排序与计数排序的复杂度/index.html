<!DOCTYPE html><html><head><title>快速排序与计数排序的复杂度分析</title><meta charset="utf-8" http-equiv="Content-Type" /><meta content="Ranmocy" name="author" /><meta content="Dec 04 2013" name="description" /><meta content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport" /><link href="https://plus.google.com/+WanzhangSheng" rel="author" /><link href="https://plus.google.com/+WanzhangSheng" rel="publisher" /><link href="atom.xml" rel="alternate" title="快速排序与计数排序的复杂度分析" type="application/atom+xml" /><meta content="blog" property="og:type" /><meta content="快速排序与计数排序的复杂度分析" property="og:title" /><meta content="所有学习过排序算法的人都知道，快速排序（Quick Sort）的时间复杂度为 `O(n*lg(n))`， `n` 为需要排序的数的个数；而计数排序（Counting Sort）的时间复杂度为 `..." property="og:description" /><meta content="http://ranmocy.info/favicon.ico" property="og:image" /><meta content="summary" name="twitter:card" /><meta content="@ranmocy" name="twitter:site" /><meta content="快速排序与计数排序的复杂度分析" name="twitter:title" /><meta content="所有学习过排序算法的人都知道，快速排序（Quick Sort）的时间复杂度为 `O(n*lg(n))`， `n` 为需要排序的数的个数；而计数排序（Counting Sort）的时间复杂度为 `..." name="twitter:description" /><meta content="http://ranmocy.info/favicon.ico" name="twitter:image" /><meta content="@ranmocy" name="twitter:creator" /><meta content="http://ranmocy.info" name="twitter:domain" /><link href="/icons/favicon.ico" rel="icon" type="image/x-icon" /><link href="/icons/favicon.ico" rel="shortcut icon" type="image/x-icon" /><link href="/icons/Icon-60@2x.png" rel="apple-touch-icon" /><link href="/icons/Icon-60@3x.png" rel="apple-touch-icon" sizes="180x180" /><link href="/icons/Icon-76.png" rel="apple-touch-icon" sizes="76x76" /><link href="/icons/Icon-76@2x.png" rel="apple-touch-icon" sizes="152x152" /><link href="/icons/Icon-Small@2x.png" rel="apple-touch-icon" sizes="58x58" /><link href='/assets/stylesheets/default.css' media='screen' rel='stylesheet' type='text/css'></head><body class="typo"><nav><span class="title"><a href='/' >快速排序与计数排序的复杂度分析</a></span><span class="date">Dec 04 2013</span><span class="link"><a href='/categories/' >Categories</a><a href='/memories/' >Memories</a><a href='/about/' >About</a></span></nav><main><article><p>所有学习过排序算法的人都知道，
快速排序（Quick Sort）的时间复杂度为 <code>O(n*lg(n))</code>， <code>n</code> 为需要排序的数的个数；
而计数排序（Counting Sort）的时间复杂度为 <code>O(m+n)</code>，<code>n</code> 为需要排序的数的个数，<code>m</code> 为数据的范围。</p>

<p>看起来计数排序时间复杂度要比快速排序的时间复杂度要低，但是实际上我接下来就会证明<em>计数排序时间复杂度并不比快速排序低，甚至会更高</em>。</p>

<p>问题的复杂度的一般化定义是关于输入字串的长度 <code>w</code> 的函数，也就是说要等价于待排序的数组在内存中的长度，
所以 <code>w = n*lg(m)</code>。
由于无论何种排序算法，都需要完整的读入整个字符串，并输出同等长度的字符串，所以任何排序算法的时间复杂度至少为 <code>O(w)</code>。</p>

<p>故，计数排序的时间复杂度实际为 <code>O(w+m+n+w) = O(w+m)</code>，其至少为 <code>O(w)</code>。当 <code>n</code> 很小，但是 <code>m</code> 很大的时候，会变为 <code>O(m)</code>。</p>

<p>再来看快速排序：</p>

<p>标准的快速排序算法在每次递归处理的时候，
首先调用 Partition 函数，选取一个数，将小于它的数放到它的左边，将大于等于它的数放到它的右边，
这个函数的时间复杂度为 <code>O(n)</code>。
然后递归处理左右两边，整体时间复杂度为 <code>O(n*lg(n))</code>。</p>

<p>考虑一种拥有对相同元素有特殊处理的快速排序算法。
我们需要修改 Partition 函数，在选取一个数后，将小于它的数放到左边，接下来是与它相等的数，之后是大于它的数，
这样，所有相等的数只会处理一遍，函数的时间复杂度仍然为 <code>O(n)</code>。
整体的时间复杂度变为 <code>O(n*lg(p))</code>，其中 <code>p</code> 为待排序的数字中不同的数的个数。</p>

<p>所以我们可以知道 <code>1 &lt;= p &lt;= m</code>，因为我们数据范围只有 <code>m</code>，至多有 <code>m</code> 个不同的数。</p>

<p>于是快速排序的时间复杂度实际为 <code>O(n*lg(m)) = O(w)</code>。</p>

<p>所以计数排序不小于快速排序的时间复杂度 <code>O(w)</code>，当 <code>m</code> 很大的时候，甚至比快速排序复杂度更高。</p>
</article><div id="disqus_thread"></div><script>/* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
var disqus_shortname = 'ranmocyblog'; // required: replace example with your forum shortname
/* * * DON'T EDIT BELOW THIS LINE * * */
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><a class="dsq-brlink" href="http://disqus.com">comments powered by<span class="logo-disqus">Disqus</span></a></main><footer><div class="piece"><span>我努力将诸多人格中微小的片面拼合。</span><span>我拨开我的大脑，只为博君一笑。</span></div><div class="piece"><span>Created by: <a href='/about/' rel="author" title="Ranmocy">Ranmocy</a></span><span>Hosted at: <a href='https://github.com/ranmocy/Brain' rel="friend" title="Github" target="_blank">Github</a></span></div><div class="piece"><span>&copy;Copyright 1991-2016 Ranmocy.</span><span>All Rights Reserved.</span></div></footer><script>var _gaq = _gaq || []; _gaq.push(['_setAccount', 'UA-20961770-4']); _gaq.push(['_trackPageview']); (function() {var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true; ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'; var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);})();</script></body></html>